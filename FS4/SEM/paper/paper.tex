\documentclass[12pt,twoside]{article}
\usepackage[ngerman]{babel}
%\usepackage{lmodern}
\usepackage[utf8]{inputenc}
%\usepackage[T1]{fontenc}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Meta informations:
\newcommand{\trauthor}{Louis Kobras}
\newcommand{\trtype}{Seminararbeit}
\newcommand{\trcourse}{Seminar: Konzepte verteilter Softwareentwicklung}
\newcommand{\trtitle}{[Arbeitstitel:]Task-Scheduling in verteilter Softwareentwicklung}
\newcommand{\trmatrikelnummer}{6658699}
\newcommand{\tremail}{4kobras@informatik.uni-hamburg.de}
\newcommand{\trarbeitsbereich}{Fachbereich oder \#Student oder so}
\newcommand{\trdate}{\today}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Bind packages:
\usepackage{acronym}                    % Acronyms
\usepackage{algorithmic}				% Algorithms and Pseudocode
\usepackage{algorithm}					% Algorithms and Pseudocode
\usepackage{amsfonts}                   % AMS Math Packet (Fonts)
\usepackage{amsmath}                    % AMS Math Packet
\usepackage{amssymb}                    % Additional mathematical symbols
\usepackage{amsthm}
\usepackage{booktabs}                   % Nicer tables
%\usepackage[font=small,labelfont=bf]{caption} % Numbered captions for figures
\usepackage{color}                      % Enables defining of colors via \definecolor
\definecolor{uhhRed}{RGB}{254,0,0}		% Official Uni Hamburg Red
\definecolor{uhhGrey}{RGB}{122,122,120} % Official Uni Hamburg Grey
\usepackage{fancybox}                   % Gleichungen einrahmen
\usepackage{fancyhdr}					% Packet for nicer headers
%\usepackage{fancyheadings}             % Nicer numbering of headlines
\usepackage{perpage}					% resets specified settings per page
\MakePerPage{footnote}					% resetting footnote count per page

%\usepackage[outer=3.35cm]{geometry} 	% Type area (size, margins...) !!!Release version
%\usepackage[outer=2.5cm]{geometry} 	% Type area (size, margins...) !!!Print version
%\usepackage{geometry} 					% Type area (size, margins...) !!!Proofread version
%\usepackage[outer=3.15cm]{geometry} 	% Type area (size, margins...) !!!Draft version
%\geometry{a4paper,body={5.8in,9in}}
\usepackage[margin=2.54cm]{geometry}

% changing font
\usepackage{times}

\usepackage{graphicx}                   % Inclusion of graphics
%\usepackage{latexsym}                  % Special symbols
\usepackage{longtable}					% Allow tables over several parges
\usepackage{listings}                   % Nicer source code listings
\usepackage{multicol}					% Content of a table over several columns
\usepackage{multirow}					% Content of a table over several rows
\usepackage{rotating}					% Alows to rotate text and objects
\usepackage[hang]{subfigure}            % Allows to use multiple (partial) figures in a fig
%\usepackage[font=footnotesize,labelfont=rm]{subfig}	% Pictures in a floating environment
\usepackage{tabularx}					% Tables with fixed width but variable rows
\usepackage{url,xspace,boxedminipage}   % Accurate display of URLs
\usepackage{hyperref}
% listing captions
\usepackage{caption}
% filler text
\usepackage{lipsum}
% tikz being tikz
\usepackage{tikz}
\usetikzlibrary{arrows,automata}
\usepackage{pgf}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Configurationen:

\hyphenation{whe-ther} 					% Manually use: "\-" in a word: Staats\-ver\-trag

%\lstloadlanguages{C}                   % Set the default language for listings
\DeclareGraphicsExtensions{.pdf,.svg,.jpg,.png,.eps} % first try pdf, then eps, png and jpg
\graphicspath{{../img/}} 								% Path to a folder where all pictures are located
\pagestyle{fancy} 											% Use nicer header and footer

% Redefine the environments for floating objects:
\setcounter{topnumber}{3}
\setcounter{bottomnumber}{2}
\setcounter{totalnumber}{4}
\renewcommand{\topfraction}{0.9} 		%Standard: 0.7
\renewcommand{\bottomfraction}{0.5}		%Standard: 0.3
\renewcommand{\textfraction}{0.1}		%Standard: 0.2
\renewcommand{\floatpagefraction}{0.8} 	%Standard: 0.5

% Tables with a nicer padding:
\renewcommand{\arraystretch}{1.2}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Additional 'theorem' and 'definition' blocks:
\theoremstyle{plain}
\newtheorem{theorem}{Theorem}[section]
%\newtheorem{theorem}{Satz}[section]		% Wenn in Deutsch geschrieben wird.
%\newtheorem{axiom}{Axiom}[section] 	
%\newtheorem{axiom}{Fakt}[chapter]		% Wenn in Deutsch geschrieben wird.
%Usage:%\begin{axiom}[optional description]%Main part%\end{fakt}

\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]

%Additional types of axioms:
%\newtheorem{lemma}[axiom]{Lemma}
%\newtheorem{observation}[axiom]{Observation}

%Additional types of definitions:
\theoremstyle{remark}
\newtheorem{remark}[definition]{Bemerkung} % Wenn in Deutsch geschrieben wird.
%\newtheorem{remark}[definition]{Remark} 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Provides TODOs within the margin:
\newcommand{\TODO}[1]{\marginpar{\emph{\small{{\bf TODO: } #1}}}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Abbreviations and mathematical symbols
\newcommand{\modd}{\text{ mod }}
\newcommand{\RS}{\mathbb{R}}
\newcommand{\NS}{\mathbb{N}}
\newcommand{\ZS}{\mathbb{Z}}
\newcommand{\dnormal}{\mathit{N}}
\newcommand{\duniform}{\mathit{U}}

\newcommand{\erdos}{Erd\H{o}s}
\newcommand{\renyi}{-R\'{e}nyi}

\newcommand{\ints}{\textsc{Interval-Scheduling} }
\newcommand{\msat}{\textsc{Max-Sat} }
\newcommand{\lb}{\textsc{Load Balancing} }
\newcommand{\ts}{\textsc{TopoSort} }

%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Formatting commands
\newcommand{\pbreak}{\paragraph*{}}
\newcommand{\ttt}[1]{\texttt{#1}}
\newcommand{\reduktion}[1]{%
	\-\\\vspace{-.4cm}
		\begin{center}
			\fcolorbox{black}{lightgray}{%
				\parbox{0.9\textwidth}{%
					#1
				}
			}
		\end{center}
	\-\\
}
\newcommand{\todo}[1]{
	\addcontentsline{toc}{subsubsection}{TODO: #1}
	\textcolor{pgreen}{\texttt{\-\\ \-\\//TODO: #1\-\\ \-\\}}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Macro commands
\newcommand{\footref}[1]{\footnote{Definition vgl. \nameref{#1}}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Source code inclusion
\definecolor{pblue}{rgb}{0.13,0.13,1}
\definecolor{pgreen}{rgb}{0,0.5,0}
\lstset{ %
language=Python,   							% choose the language of the code
basicstyle=\small\ttfamily,  				% the size of the fonts that are used for the code
numbers=left,                   			% where to put the line-numbers
numbersep=5pt,                  			% how far the line-numbers are from the code
backgroundcolor=\color{light-light-gray},   % choose the background color. You must add
frame=lrtb,           						% adds a frame around the code
tabsize=4,          						% sets default tabsize to 2 spaces
captionpos=b,           					% sets the caption-position to bottom
breaklines=true,        					% sets automatic line breaking
xleftmargin=1.5cm,							% space from the left paper edge
commentstyle=\color{pgreen},
keywordstyle=\color{pblue},
literate=%
    {Ö}{{\"O}}1
    {Ä}{{\"A}}1
    {Ü}{{\"U}}1
    {ß}{{\ss}}1
    {ü}{{\"u}}1
    {ä}{{\"a}}1
    {ö}{{\"o}}1
    {~}{{\textasciitilde}}1
}
\renewcommand{\lstlistingname}{Code}
\captionsetup[lstlisting]{font={footnotesize},margin=1.5cm,singlelinecheck=false } % removes "Listing 1: "
\definecolor{light-light-gray}{gray}{0.95}

% decreasing space used above and below figures
\setlength{\belowcaptionskip}{-10pt}
\setlength{\abovecaptionskip}{10pt}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Document:
\begin{document}
\renewcommand{\headheight}{14.5pt}

\fancyhead{}
\fancyhead[LO]{ \slshape \trauthor}
\fancyhead[RE]{ \slshape \trtitle}

\renewcommand{\footrulewidth}{.4pt}

\fancyfoot{}
\fancyfoot[LE,RO]{\thepage}

% flags for compiling
%% set counts other than 'True' to 1 to print the corresponding section
\newcount\True
\True=1
%% lipsum filler text
\newcount\Lopsum
\Lopsum=0


%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Cover Header:
\begin{titlepage}
	\begin{figure}[!h]
		\begin{minipage}[t]{0.5\textwidth}
		\vspace{0pt}
		\begin{flushleft}
			Universität Hamburg\\
			Fachbereich Informatik\\
			\trarbeitsbereich
		\end{flushleft}
		\end{minipage}
		\hfill
		\begin{minipage}[t]{0.48\textwidth}
			\vspace{0pt}
			\begin{flushright}
				\includegraphics[scale=.3]{uhh-logo}
			\end{flushright}
		\end{minipage}
	\end{figure} 
	\vspace{3.5cm}
	\begin{center}
		\huge \trtitle\\
	\end{center}
	\vspace{3.5cm}
	\begin{center}
		\normalsize\trtype\\
		[0.2cm]
		\Large\trcourse\\
		[1.5cm]
		\Large \trauthor\\
		[0.2cm]
		\normalsize Matr.Nr. \trmatrikelnummer\\
		[0.2cm]
		\normalsize\tremail\\
		[1.5cm]
		\Large \trdate
	\end{center}
	\vfill
\end{titlepage}

	%backsite of cover sheet is empty!
\thispagestyle{empty}
\hspace{1cm}
\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Abstract:

% Abstract gives a brief summary of the main points of a paper:
\section*{Abstract}
\lipsum[99]
% Lists:
\setcounter{tocdepth}{3} 					% depth of the table of contents (for Seminars 2 is recommented)
\tableofcontents
\pagenumbering{arabic}
\clearpage

\section{Motivation}
\label{sec:intro}
Scheduling ist ein kritischer Punkt in großen (Entwicklungs-)Projekten.
Besteht ein Entwicklerteam aus nur wenigen Leuten, so lassen sich mit relativ geringem Aufwand Punkte finden, an denen sich etwa eine Teambesprechung anbietet, oder eine Deadline festlegen, wann eine Ressource wieder freigegeben werden muss.
Mit wachsender Projektgröße steigt die Anzahl an Anforderungen jedoch immens.

Jede einzelne Person hat private Termine, die eingehalten werden müssen; Teilgruppen innerhalb des Teams müssen sich absprechen; der Kunde will betreut werden; Ressourcen müssen wieder freigegeben werden; Projektteile warten auf andere Projektteile.

All diese Bedingungen und Abhängigkeiten zu vereinen, ist eine zunehmend komplexe Aufgabe, je mehr das Team anwächst, je größer das Projekt wird.

Ziel dieser Arbeit ist es, mithilfe von Algorithmen aus der theoretischen Informatik ein Modell zu finden, welches all jenes miteinander vereint und in der Lage ist, einen optimierten Zeitplan zu bestimmen, der sämtliche ihm bekannten Termine und Abhängigkeiten berücksichtigt.

Dazu wird sich verschiedenen Problemen aus der $NPH$-Klasse bedient, deren Lösungsalgo-rithmen zwar eine lange Laufzeit haben, von denen sich jedoch einige zur Modellierung des hier gegebenen Problems anbieten.
Zum Abschluss soll ein gefundenes Schedule evaluiert werden:
Kann es aus Sicht des Teams optimiert werden, d.h. kann die gesamte Projektlaufzeit verkürzt werden?
Kann es aus Sicht eines Agenten optimiert werden, d.h. ist das Schedule derart gestaltet, dass die Wartezeiten jedes einzelnen Agenten minimal sind?
Hierzu wird sich einiger Grundkonzepte der Spieltheorie bedient.

\section{Warum kein Dudel?}
\label{sec:dudel}
Dudel oder etwas Vergleichbares ist sicherlich vielen ein Begriff.
Geht es darum, einen einzelnen Zeitslot zu finden, an dem möglichst viele Agenten zur Verfügung stehen, so ist Dudel durchaus eine überlegenswerte Lösung.
Sowohl das Erstellen als auch das Abstimmen ist einfach in der Handhabung.
Dennoch gibt es mehrere Gründe, warum für große Projekte Dudel ausscheidet.
\paragraph{Mangel an Übersichtlichkeit.}
Bei einem großen Projekt, welches von großem wirtschaftlichem Interesse für einen Kunden ist, kann es nötig sein, für einen Termin auf einen sehr feingliedrigen Zeitplan zurückzugreifen.
Auch wenn die Erstellung, die Verwaltung und die Teilnahme an einem Dudel selbsterklärend sind, so nimmt die Komplexität zu, umso feingliedriger der Zeitplan sein soll.
Ausgehend von einer Vollzeitwoche mit möglichen Zeitslots zu jeder Viertelstunde ergibt sich somit eine Zeitslotliste der Mächtigkeit $(8\text{h}\cdot4\text{ Slots pro Stunde})\cdot5\text{ Tage }=160$ Slots in einer Woche.
Dies ergibt eine Matrix mit den Ausmaßen ($160 \times$Anzahl beteiligter Agenten).
Bei einer derartigen Tabelle den Überblick zu behalten, sprengt den Rahmen realistischer Erwartungen an einen menschlichen Agenten in verwaltender Position.
\paragraph{Persönliche Motivation.}
Gegeben ein Arbeitstag von mehreren Stunden, ist es durchaus nicht undenkbar, dass ein Agent am Abend die Ressource Zeit, die ihm zur Verfügung steht, nicht freigibt, es sei denn, es ist erforderlich.
Dies ist gerade bei einem Dudel leicht durchzuführen und schwer nachzuvollziehen.
Ein System, welches die Zeitpläne als Rohmaterial erhält, nimmt keine Rücksicht auf persönliche Abneigungen und eliminiert deswegen diesen Fall.
\paragraph{Nichtoptimierung.}
Ein Dudel zählt lediglich, wie viele Agenten zu welchen Zeitslots zur Verfüg-ung stehen; es wird nicht weiter auf die Art der Blockierung der anderen Zeitslots eingegangen.
Ein System, welches direkt mit Deadlines und Abhängigkeiten arbeitet, kann dazu im Stande sein, den Schedule derart zu berechnen, dass Wartezeiten reduziert werden, und ist deswegen potentiell in der Lage, einen optimierten Schedule zu erstellen, der die allgemeine Projektdauer reduziert und die Wartezeiten einzelner Agenten minimiert und somit die Produktivität maximiert.
\paragraph{Einzelläufigkeit.}
Ein Dudel hat nicht das Potenzial, nebenläufige Entwicklungsprozesse zu be-rücksichtigen.
Es wird ein Zeitstrahl vorgegeben, auf dem maximierende Belegungen ausgegeben werden.
Dem entgegen steht der Umstand, dass durchaus Sachen gleichzeitig geschehen können; so auch Termine, an denen Teilmengen der Agenten beteiligt sind.
Für alle solche Ereignisse ein neues Dudel zu erstellen, ist umständlich und kann, da jeder Agent an mehreren Dudels teilnehmen muss, zu einer zeitlichen Belastung werden und somit die Produktivität senken.
\pbreak
Diese Gründe legen dar, warum die Dudel-Variante in großen Agentensystemen ungeeignet ist und ein eher dynamisch veranlagtes System zur Berechnung eines Schedules erforderlich ist.

\section{Zerlegung in Teilprobleme}
Da es leider den einen Superalgorithmus, der ein beliebig komplexes Problem in polynomieller Laufzeit löst, gibt, muss ein schwierigeres Problem in einfachere Teilprobleme aufgeteilt werden, die sich besser lösen lassen und für die möglicherweise schon eine Lösung bekannt ist.
Zuerst wird die Fragestellung dreigeteilt in Eingabe, Rechnung und Ausgabe.
\pbreak
Die Eingabe nimmt die Zeiten eines jeden Akteurs und bestimmt daraus ein Format, mit dem weiter gearbeitet werden kann.
Hierbei wird von allen Teilnehmern am Schedule erwartet, dass sie sämtliche Zeiträume eintragen, in denen sie nicht zur Verfügung stehen, sowie sämtliche Tasks, die sie betreffen, wobei der Projektleiter die Möglichkeit haben soll, die Projekt-Deadline anzugeben.
Der Algorithmus soll dabei Duplikate erkennen und eliminieren können.

Diese Eingaben werden auf eine Form gebracht, die vom Algorithmus verarbeitet werden kann.

Anschließend werden diese verarbeiteten Eingaben sortiert, um einen Überblick darüber zu erhalten, wie ein Schedule aufgebaut ist.
Hier kann bereits geprüft werden, ob es theoretisch ein Schedule geben kann, welches die Ramenbedingungen einhält, indem geprüft wird, ob ein einzelner Task mehr Ressourcen benötigt, als zur Verfügung stehen.
\pbreak
Die Rechnung wendet Lösungs- und Approximationsalgorithmen für bekannte und gelöste Probleme an, um die Aufgaben gleichmäßig zu verteilen, so dass ein Task von einer qualifizierten Entität bearbeitet wird, keine Entität gleichzeitig mehrere Tasks zu bearbeiten hat und keine übermäßigen Wartezeiten für untätige Entitäten entstehen.
Dies impliziert eine größtmögliche Parallelisierung von wechselseitig unabhängigen Teilaufgaben.

Hierbei wird (nach der Sortierung in der Eingabe) darauf geachtet, dass alle Abhängigkeiten eines Tasks erfüllt sind, bevor er zugewiesen wird, und dass kein Task eine Deadline überschreitet.

Das System soll in der Lage sein, dynamisch im Hinblick auf zu erfüllende Abhängigkeiten eigene Deadlines für Meilensteine der Entwicklung festzulegen.
\pbreak
Die Ausgabe übernimmt den errechneten Schedule und erstellt daraus ein Diagramm, welches leicht lesbar und verständlich sein soll.
Als Muster bieten sich Gantt-Diagramme oder Commit-Trees von Versionsverwaltungssystemen an.

\section{Eingabe}
\label{sec:eingabe}
\todo{normierung}
\pbreak
Es wird eine Reihe von Tasks erwartet, die allesamt eine (möglicherweise leere) Liste von Abhäng-igkeiten sowie optional eine Deadline besitzen.
Diese Tasks werden mithilfe von \ts soriert.

Dazu folgende Reduktion:
\reduktion{
	Es wird ein gerichteter Graph konstruiert.
	Zunächst werden alle Task-Listen konkateniert.
	Diese Liste wird sortiert; Duplikate werden eliminiert.
	
	Für jeden Task wird nun ein Knoten erzeugt; ist ein Task von einem anderen abhängig, so wird eine Kante entgegen der Richtung der Abhängigkeit zwischen den Knoten hinzugefügt.
	Auf diesem so entstandenen Graphen wird \ts durchgeführt.
	\paragraph*{Hinrichtung.}
	Ist \ts erfolgreich, so gibt es keine Zyklen im Graphen, alle bekannten Abhängigkeiten können also aufgelöst werden.
	
	Ist \ts nicht erfolgreich, so gibt es Zyklen im Graphen.
	Dies bedeutet, dass nicht alle Abhängigkeiten aufgelöst werden können, da einige Tasks indirekt von sich selber abhängen.
	In diesem Fall tritt eine Deadlock-Situation auf.
	Diese lässt sich dadurch beheben, einzelne Tasks zurückzuziehen, die einen Zyklus erzeugen.
	Andernfalls lässt sich kein vollständiges Schedule erzeugen.
	\paragraph*{Rückrichtung.}
	Wenn es ein vollständiges Schedule gibt, so müssen alle Abhängigkeiten auflösbar sein.
	In diesem Fall lässt sich also ein Graph konstruieren, auf dem \ts erfolgreich terminiert.
	
	Gibt es kein vollständiges Schedule aus dem Grund nicht aufgelöster Abhängigkeiten, so liegt dies daran, dass eine Abhängigkeit ewig auf Erfüllung wartet.
	Dies tritt nur bei Deadlock-Sitationen auf.
	Somit existiert im konstruierten Graphen ein Zyklus und \ts terminiert erfolglos.
}

\section{Approximation durch NP-schwere Probleme}
\label{sec:approx}
Zur Lösung eines Problems bietet es sich an, nach ähnlichen Problemen zu suchen, die bereits gelöst sind.
In diesem Fall bieten sich folgende Probleme an:
\begin{itemize}
	\item \ints\footref{def:prob:interval-scheduling}
	\item \msat\footref{def:prob:max-sat} / Knapsack
	\item \lb\footref{def:prob:load-balancing}
\end{itemize}
\ifnum\Lopsum=\True
	\lipsum[7-27]
	\lipsum[52-55]
\fi

\begin{algorithm}[H]
	\caption{\textsc{schedule(List tasks, Date deadline)}}
	\label{alg:schedule}
	\begin{algorithmic}[1]
		\FOR{task \textbf{in} tasks}
			\IF{task.timeRequirement \textbf{is greater than} deadline.isAway}
				\RETURN \ttt{\textbf{false}}
			\ENDIF
		\ENDFOR
		\STATE \ttt{Array A = TopoSort(tasks)}
	\end{algorithmic}
\end{algorithm}

\section{Lösungsansatz}
\label{sec:sol}
\ifnum\Lopsum=\True
	\lipsum[28-39]
\fi
\todo{[sic]}
\section{Bewerten einer Lösung}
\label{sec:eval}
\ifnum\Lopsum=\True
	\lipsum[40-50]
	\lipsum[9999]
\fi
\todo{[sic]}
\newpage
\addcontentsline{toc}{section}{Definitionen}
\section*{Definitionen}
\paragraph*{Nash-Gleichgewicht.}
	\label{def:st:nash}
	(Spieltheorie) Eine Situation, in der alle beteiligten Agenten die Strategie aller anderen Agenten kennen und kein Agent die Motivation hat, einseitig von seiner Strategie abzuweichen
\paragraph*{Pareto-Optimum.}
	\label{def:st:pareto}
	(Spieltheorie) Eine Situation, in der keine Partei ihre eigene Position verbessern kann, ohne dass sich die Position einer anderen Partei verschlechtert.
\paragraph*{Auszahlungsoptimiert}
	\label{def:st:auszahlung}
	Eine Strategie ist für eine Entität auszahlungsmaximiert genau dann, wenn alle anderen Strategien, die diese Entität wählen kann, gleich viel oder weniger Gewinn bringen.
	
	Eine Strategie ist für eine Gruppe auszahlungsmaximiert genau dann, wenn sie für alle Entitäten in der Gruppe auszahlungsmaximiert ist (also ein pareto-optimales Nash-Gleichgewicht vorliegt).
\paragraph*{Task.}
	Der Begriff \textit{Task} wird hier als Oberbegriff für Aufgaben, Termine und Veranstaltungen verwendet.
\paragraph*{Entität.}
	Der Begriff \textit{Entität} bezeichnet hier entweder einen Akteur oder eine Gruppe bzw. Partei.
\paragraph*{Akteur.}
	Oberbegriff für handende Menschen und Maschinen
\paragraph*{Deadline.}
	\begin{enumerate}
		\item[a.] Abschlusszeitpunkt eines Projektes
		\item[b.] Zeitpunkt, zu dem ein Task spätestens erledigt sein muss, um den Schedule einzuhalten
	\end{enumerate}
\paragraph*{\lb .}
	\label{def:prob:load-balancing}
	(NP-schweres Problem nach \cite{Andreae2016})
		\subparagraph*{Eingabe.}$m$ identische Maschinen, $n$ Jobs, Job $j$ besitzt die Ausführungsdauer $t_j$.
		Ein Job muss von einer einzelnen Maschine vollständig ohne Unterbrechung bearbeitet werden.
		Eine Maschine kann nur einen Job zur Zeit erledigen.
		\subparagraph*{Frage.} Gibt es eine Verteilung aller Jobs auf alle Maschinen derart, dass die Produktionsdauert minimiert ist?
\paragraph*{\ints .}
	\label{def:prob:interval-scheduling}
	\todo{[sic]}
	(NP-vollständiges Problem nach \cite{Andreae2016})
		\subparagraph*{Eingabe.}
		\subparagraph*{Frage.}
\paragraph*{\msat .}
	\label{def:prob:max-sat}
	\todo{[sic]}
	(NP-schweres Problem nach \cite{Andreae2016})
		\subparagraph*{Eingabe.}
		\subparagraph*{Frage.}
\paragraph*{Projekt.}
\todo{PMBoK Definition}
		
\newpage
\bibliographystyle{plain}
\addcontentsline{toc}{section}{Quellenverzeichnis}% Add to the TOC
\bibliography{bib}
\nocite{*}

\end{document}