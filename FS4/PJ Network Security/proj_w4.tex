\documentclass[twoside]{article}

\usepackage[ngerman]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

\usepackage{fancyhdr}

\usepackage[margin=2.54cm]{geometry}

\usepackage{listings}

\usepackage{xcolor}

\usepackage{hyperref}

\newcommand{\say}[1]{%
	``#1''%
}
\newcommand{\ttt}[1]{%
	\texttt{#1}%
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Source code inclusion
\definecolor{pblue}{rgb}{0.13,0.13,1}
\definecolor{pgreen}{rgb}{0,0.5,0}
\lstset{ %   							% choose the language of the code
basicstyle=\small\ttfamily,  				% the size of the fonts that are used for the code
numbers=left,                   			% where to put the line-numbers
numbersep=5pt,                  			% how far the line-numbers are from the code
backgroundcolor=\color{light-light-gray},   % choose the background color. You must add
frame=lrtb,           						% adds a frame around the code
tabsize=4,          						% sets default tabsize to 2 spaces
captionpos=b,           					% sets the caption-position to bottom
breaklines=true,        					% sets automatic line breaking
xleftmargin=1.5cm,							% space from the left paper edge
commentstyle=\color{pgreen},
keywordstyle=\color{pblue},
literate=%
    {Ö}{{\"O}}1
    {Ä}{{\"A}}1
    {Ü}{{\"U}}1
    {ß}{{\ss}}1
    {ü}{{\"u}}1
    {ä}{{\"a}}1
    {ö}{{\"o}}1
    {~}{{\textasciitilde}}1
}
\renewcommand{\lstlistingname}{Code}
\definecolor{light-light-gray}{gray}{0.95}


\begin{document}
\pagestyle{fancy}
\fancyhead{}
\fancyfoot{}
\fancyhead[L]{Louis Kobras\\6658699}
\fancyhead[R]{Utz Pöhlmann\\6663579}
\fancyfoot[RE,LO]{Seite \thepage}

\begin{center}
\begin{Huge}
\textbf{SVS Bachelor-Projekt Network Security}
\end{Huge}\\\-\\
\begin{Large}
\textbf{Blatt 4: Sniffing und Scanning}
\end{Large}\\\-\\
\begin{minipage}[t]{0.48\textwidth}
\begin{center}\textbf{
	Louis Kobras\\
	6658699}
\end{center}
\end{minipage}
\begin{minipage}[t]{0.48\textwidth}
\begin{center}\textbf{
	Utz Pöhlmann\\
	6663579}
\end{center}
\end{minipage}
\end{center}

\section{Vertrautmachen mit der Umgebung}
\subsection{}
\begin{itemize}
	\item VMs in unser Verzeichnis kopiert und geöffnet
	\item Angegeben, dass VMs kopiert wurden
	\item Bootreihenfolge: MysteryVM, SurfingVM, RoutingVM
	\item RoutingVM hat 2 Netzwerkadapter: NAT und Host-Only
\end{itemize}
\subsection{}
\begin{itemize}
	\item SurfingVM hat keine IP auf eth1
	\item Zurücksetzen der Datei \ttt{/etc/udev/rules.d/70-persistent-net.rules} mit root-Rechten
	\item Rebooten der SurfingVM
	\item \textbf{Standartgateway: 192.168.254.1}
	\item IP: 192.168.254.44
	\item \textbf{DNS-Nameserver: 10.1.1.1} (ermittelt mit \ttt{route -n}, bestätigt mit \ttt{nslookup ubuntu.com})
\end{itemize}
\subsection{}
\begin{itemize}
	\item Netzwerkkarte 1: eth0, 172.16.137.222
	\item Netzwerkkarte 2: eth1, 192.168.254.1
	\item VMWare-Standart-Gateway: 172.16.137.2
\end{itemize}
\subsection{}
\begin{itemize}
	\item Ping an 10.1.1.2 aus beiden VMs erfolgreich (0\% Package loss)
\end{itemize}

\section{Sniffing mit tcpdump}
\subsection{}
\begin{itemize}
	\item \ttt{tcpdump} listet alle Pakete auf, die über die Netzwerkkarte laufen
	\item Capture-Filter zum Filtern und Sortieren der gefangenen Packages
\end{itemize}
\subsection{}
\begin{itemize}
	\item Kommando: \ttt{sudo tcpdump -p -i eth1 -s 0 -vvv udp port 53 > log}\footnote{-p: weil Aufgabe. -i ethX: Adapter, der gelistened werden woll. -s 0: Größe des Capture in Bytes (0=alle). -vvv: alle Paketinformationen ausgeben. <<schnittstelle>> port <<port>>. > log: in die Datei 'log' echoen, die ggf. im \$(pwd) angelegt wird.} (\cite{uwtcpdump}, \cite{daniel})
\end{itemize}
\subsubsection{Anfrage}
Output:
\begin{lstlisting}
14:01:53:677232 IP (tos 0x0, ttl 64, id 1258, offset 0, flags [DF], proto UDP (17), length 60)
    192.168.254.44.35616 > server.svslab.domain: [udp sum ok] 19679+ A? www.google.com. (32)
\end{lstlisting}
Aufbau (\cite{alex}):
\begin{lstlisting}
timestamp protocoll (package-information)
	nameserver > local-domain checksum-check some-number Question? target. (num)
\end{lstlisting}
\textit{Anmerkung:} tcpdump kennt nur wenige Protokolle und gibt, wenn er ein Protokoll nicht erkennt, IP an.
\subsubsection{Antwort}
Output:
\begin{lstlisting}
14:01:53.677765 IP (tos 0x0, ttl 127, id 21488, offset 0, flags [none], proto UDP (17), length 212)
    server.svslab.domain > 192.168.254.44.35616: [udp sum ok] 19679 q: A? www.google.com. 1/4/4 www.google.com. [2m33s] A 216.58.213.228 ns: google.com. [1d21h4m48s] NS ns1.google.com., google.com. [1d21h4m48s] NS ns3.google.com., google.com. [1d21h4m48s] NS ns2.google.com., google.com. [1d21h4m48s] NS ns4.google.com. ar: ns1.google.com. [3d21h12m22s] A 216.239.32.10, ns2.google.com. [3d21h12m22s] A 216.239.34.10, ns3.google.com. [3d21h12m22s] A 216.239.36.10, ns4.google.com. [3d21h12m44s] A 216.239.38.10 (184) 
\end{lstlisting}
Wieder ist die erste Zeile Meta-Information.
Die zweite Zeile ist eine Anfrage unserer Domain an unseren Nameserver, welcher dann an Google weiterfragt, wo die Nameserver von Google die Anfrage durch reichen.
\subsection{}
\begin{itemize}
	\item Kommando: \ttt{sudo tcpdump -p -i eth1 -s 0 -vvv '(tcp port 80) or (tcp port 443)' > log}\footnote{s.o., tcp port 80 für HTTP, tcp port 443 für HTTPS} (\cite{uwtcpdump})
\end{itemize}
Output:
\begin{lstlisting}
14:27:10.394893 IP (tos 0x0, ttl 64, id 18592, offset 0, flags [DF], proto TCP (6), length 60)
    192.168.254.44.35453 > ham04s01-in-f4.1e100.net.www: tcp 0 
\end{lstlisting}
Fazit: Unser Nameserver brennt mit einem Hamster durch.
\subsection{}
Neuer Befehl: \ttt{sudo tcpdump -p -i eth1 -s 0 -vvv -A 'tcp port 80'}
Output vgl. Anhang 2
\subsection{}
\begin{itemize}
	\item Aufrufen der URL \ttt{http://10.1.1.2/verysecure/}
	\item Eingabe der Login-Daten \ttt{alice:sehrgeheim}
	\item Login-Daten im Package:
\begin{lstlisting}
Authorization: Basic YWxpY2U6c2V0cmdlaGVpbQ==
\end{lstlisting}
	$\Rightarrow$ Base-64-verschlüsselt.
	\item Entschlüsselung ergibt: \ttt{alice:sehrgeheim}
\end{itemize}


\section{Sniffing mit dsniff und urlsnarf}
\subsection{urlsnarf}
Befehl:
\begin{lstlisting}
sudo urlsnarf -i eth1 > log
\end{lstlisting}
Aufbau des Output: IP - Timestamp - Adresse - Protokoll - Browser - Systemdaten\\
Befehl greift alle HTTP-Pakete vom angegebenen Adapter ab und zeigt ihre Daten an.
\subsection{dsniff}
Befehl:
\begin{lstlisting}
sudo dsniff -i eth1 > log
\end{lstlisting}
Aufbau des Output: Timestamp - Senderadresse - Empfängeradresse - Adresse - Protokoll - Host - Paketinhalt (decoded)\\
Liest den Inhalt von HTTP-Paketen aus und decodiert (zumindest Base-64).
\section{Sniffing mit Wireshark}
\subsection{}
Wireshark liefert eine graphische Darstellung der gesnifften Pakete in lesbarer Tabellenform und zeigt den Inhalt der Pakete an.
\subsection{}
\paragraph{Display-Filter.}
Bestimmt, welche der aufgefangenen Pakete angezeigt werden.
\paragraph{Capture-Filter.}
Bestimmt, welche Pakete aufgefangen werden.
\subsection{}
Wireshark wurde geöffnet.
\subsection{}
\begin{itemize}
	\item \ttt{eth1} liegt nahe, da dieses Interface das Gateway für die SurfingVM bereitstellt (Capture-Filter).
	\item Alternativ zur Interface-Wahl kann ein Display-Filter zur Steuerung des Outputs erstellt werden.
\end{itemize}
\subsection{}
Es wird nur ein Ping gesendet. (\#Easteregg).
Der Server pingt zurück.
Die Pings werden über ICMP\footnote{Internet Control Message Protocol} übertragen.

Der Klient DARF die Daten so lange behalten, wie er will.
Jedes Paket hat einen time-to-live-Eintrag; ist dieser überschritten, wird das Paket erneut angefordert.

Weil Linux den DNS nicht cached, erwarten wir die gleiche Antwort.

Wir bekommen die gleiche Antwort, was bedeutet, Linux cached den DNS nicht.

Der Browser sendet Pings über TCP und anschließend HTTP.
Dies wechselt sich stetig ab.

Es würde erwartet, dass in beiden Fällen das Gleiche passiert
\subsection{}
Erstellen des Filters:
\begin{enumerate}
	\item Kontextmenü eines HTTP-Eintrages
	\item Klick auf ``Apply as filter''
	\item Fertig
\end{enumerate}
\subsection{}
Funktion liegt unter Menüreiter ``Analyze''.

Ausgabe eines HTTP-Response öffnet Popup, in welchem der Content des Package angezeigt wird.
Es kann zwischen verschiedenen Darstellungen gewählt werden (Raw/ASCII, HexDump, C Arrays)
\subsection{}
\begin{itemize}
	\item Server starten auf RoutingVM
	\item Auf SurfingVM mit telnet auf Server einwählen
	\item Auf RoutingVM Wireshark starten
	\item Auf SurfingVM Dinge tun
	\item Auf der RoutingVM kann der gesamte Chat nun als TCP-Packages ausgelesen werden (u.a. auch die Login Daten)
\end{itemize}
\subsection{}
\begin{itemize}
	\item Aufrufen von \url{https://de-de.facebook.com}
	\item Verwendete Protokolle: TCP, TLSv1
	\item Es wurden nicht alle Pakete in Wireshark angezeigt (Nummerierung nicht durchgehend).
	Kein Filter eingestellt.
	Theorie: HTTPS wird verborgen.
\end{itemize}



\section{ARP-Spoofing}
\subsection{}
Ablauf des ARP-Spoofings:
\begin{itemize}
	\item 'Angreifer' sendet gefälschtes ARP-Paket mit seiner eigenen MAC-Adresse an Entity A, sodass Entity A ihre Pakete an den 'Angreifer' schickt statt an Entity B.
	\item Gleiches geschieht mit Entity B in Bezug auf Entity A.
	\item 'Angreifer' liest die Pakete von Entity A aus und leitet sie an Entity B weiter, und umgekehrt.
\end{itemize}
Funktionsweise von \ttt{arpspoof}:
\begin{itemize}
	\item Abzufangender Adapter wird angegeben
	\item Entity, die gespooft werden soll
	\item Domain, deren eingehender Datenstream mitgelesen werden soll
\end{itemize}
\subsection{}
Befehl: \ttt{sudo arpspoof 172.16.137.2}.
Es wird eine lange Reihe identischer arp-Replys ausgegeben.
\subsection{}
Es wurde der Wireshark-Adapter ``any'' ausgewählt.
\subsection{}
\begin{itemize}
	\item Display Filter auf \ttt{ICMP}
	\item IP-Adresse 172.16.137.146 durch Ping-Intervall ermittelt
\end{itemize}
\subsection{}
\begin{itemize}
	\item Display-Filter \ttt{ip.addr==172.16.137.146 \&\& pop}
	\item beliebigen Eintrag ausgewählt und per Rechtsklick \say{Follow TCP Stream}
	\item Nutzerdaten: \ttt{USER bumblebee}, \ttt{PASS Optimus Prime}
	\item hat eine ungelesene Mail von root@labservervm
	\item Alternativen: EInhalten von Verdecktheit und Verborgenheit (GSS Sicherheitsziele :P)
\end{itemize}
\subsection{}
	\begin{itemize}
		\item Browser/Version: Mozilla/5.0
		\item URL: http://10.1.1.2/secure/secret.html
		\item Login-Daten: Base-64 encoded im Kopf des Paketes; Daten: \ttt{admin:geheim}
	\end{itemize}
Widersprüche zwischen Erkenntnissen:
\begin{itemize}
	\item None
\end{itemize}
\subsection{}
\ttt{arpspoof} wurde am Ende des Experiments mit Ctrl-C abgebrochen.

\section{Scanning mit nmap}
\subsection{}
Die 5 coolsten NMAP-Funktionen (nach \cite{nmap})
\begin{enumerate}
	\item Security audits
	\item network inventory
	\item managing service upgrade schedules
	\item monitoring host uptime
	\item monitoring service uptime
\end{enumerate}
\subsection{}
\begin{itemize}
	\item Skript vgl. Anhang 4
	\item gewählte Sprache: Bash
	\item Liste aktiver Rechner:
	\begin{itemize}
		\item 10.1.1.1
		\item 10.1.1.2
		\item 10.1.1.5
		\item 10.1.1.11
		\item 10.1.1.21
		\item 10.1.1.31
		\item 10.1.1.41
		\item 10.1.1.51
		\item 10.1.1.61
		\item 10.1.1.71
		\item 10.1.1.81
		\item 10.1.1.91
		\item 10.1.1.101
		\item 10.1.1.111
		\item 10.1.1.121
		\item 10.1.1.131
		\item 10.1.1.181
		\item 10.1.1.186
		\item 10.1.1.218
		\item 10.1.1.222
		\item 10.1.1.235
		\item 10.1.1.238
		\item 10.1.1.254
	\end{itemize}
\end{itemize}
\subsection{}
\begin{itemize}
	\item \ttt{nmap} sagt, alle sind up.
	\item ping sagt, fast alle sind down.
	\item \ttt{nmap} lügt. >.<
	\item \ttt{nmap} erzeugt:
		\begin{itemize}
			\item Ping (ICMP)
			\item Senden eines HTTPS-Package (TCP)
			\item Senden eines HTTP-Package (TCP)
			\item Timestamp anfragen (ICMP)
			\item Antwort auf HTTP von Remote Host (TCP)
		\end{itemize}
	\item \ttt{nmap} erzeugt bei einem Host, den \ttt{ping} gefunden hat:
		\begin{itemize}
			\item Ping (ICMP)
			\item Ping Response vom Remote Host (ICMP)
			\item Senden eines HTTPS-Package (TCP)
			\item Senden eines HTTP-Package (TCP)
			\item Timestamp anfragen (ICMP)
			\item Antwort auf HTTP von Remote Host (TCP)
		\end{itemize}
	\item Ermittlung des Up-Status durch Erhalt der HTTP-Antwort
\end{itemize}
\subsection{}
\begin{itemize}
	\item Three-Way-Handshake: SequenceNumber(SYN) (x) von Client and Host, Rücksenden von SequenceNumber (y) und AcknowledgeNumber(ACK) (x+1) von Host an Client, Rücksenden von AcknowledgeNumber (y+1) Client an Host. (\cite{wiki3})
	\item TCP-Connect-Scan durch \ttt{sudo nmap -sT 10.1.1.2} (vollständiger 3-way-handshake, (SYN)->(SYN+ACK)->(ACK))
	\item TCP-SYN-Scan durch \ttt{sudo nmap -sS 10.1.1.2} (nur halber handshake, (SYN)->(SYN+ACK))
\end{itemize}
\subsection{}
\begin{itemize}
	\item Scannen aller Ports mit \ttt{sudo nmap -p- -sV 172.16.137.146 -oG logs.txt}
	\item Output enthält \ttt{5288/open/tcp//http//Apache httpd 2.2.14 ((Ubuntu))/}
	\item Apache-Webserver im Browser aufgerufen mit 172.16.137.146:5288 (Secret Site)
\end{itemize}


\section{OpenVAS}
\subsection{}
Wir haben uns ein wenig mit OpenVAS vertraut gemacht.
\subsection{}
Start des OpenVAS-Servers mit \ttt{/etc/init.d/openvas-server start}\\
\textbf{FEHLGESCHLAGEN}, weil der VAS-Daemon Dinge nicht laden konnte.
\subsection{}
Startet
\subsection{}
Login auf dem Server als user@localhost:user
\subsection{}
Es wurde auf das Fragezeichen geklickt und der Assistent durchgearbeitet.
Währenddessen wurde als Name \say{localhost} und als IP-Adresse die eigene IP-Adresse gewählt.
Danach würde auf das Stecker-Symbol gekilckt, die Daten eingegeben und \say{ok} betätigt.

Es wurden keine Schwachstellen gefunden (exportierter Report enthält \say{Number of security holes: 0; Number of security warnings: 0}

Note: OpenVAS-Scan-Server ist veraltet.

Eingabe: File -> Scan Assistant -> Task: \$name -> Scope: \$name -> Targets: IP der MysteryVM (172.16.137.146) -> Execute
\subsection{}
MysteryVM hat eine Sicherheitslücke und zwei Sicherheitswarnungen.

Login-Daten: root:password
\subsection{}

\newpage
\section*{Anhang 1:}


\section*{Anhang 2}
\subsection*{Output des HTTP-Sniffing}
\begin{lstlisting}
14:37:51.282324 IP (tos 0x0, ttl 64, id 51836, offset 0, flags [DF], proto TCP (6), length 487)
    192.168.254.44.35465 > ham04s01-in-f4.1e100.net.www: Flags [P.], cksum 0xbb75 (correct), seq 311797790:311798237, ack 398350995, win 9648, length 447
E....|@.@......,.:.....P......Z.P.%..u..GET / HTTP/1.1
Host: www.google.com
User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux i686; rv:10.0.1) Gecko/20100101 Firefox/10.0.1
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-us,en;q=0.5
Accept-Encoding: gzip, deflate
Connection: keep-alive
Cookie: NID=79=WlzebisuVRgORNA05jSpuedXCNNs1eBM8yEMd8n30_OluRdkzWbkChEEQ4YgUvHTWB3a64hs LjaseRkBrUN1vGIU56_9YOWlq0yWpZRTS4cdFs9-0wKsmJyANZ1uZ7UPnFbMMSPb
\end{lstlisting}

\section*{Anhang 3: Outputs von urlsnarf und dsniff}
\begin{lstlisting}
urlsnarf

192.168.254.44 - - [26/May/2016:15:03:07 +0200] "GET http://10.1.1.2/verysecure/ HTTP/1.1" - - "-" "Mozilla/5.0 (X11; Ubuntu; Linux i686; rv:10.0.1) Gecko/20100101 Firefox/10.0.1"

dsniff

dsniff: listening on eth1
-----------------
05/26/16 15:06:17 tcp 192.168.254.44.56594 -> labservervm.svslab.80 (http)
GET /verysecure/ HTTP/1.1
Host: 10.1.1.2
Authorization: Basic YWxpY2U6c2VocmdlaGVpbQ== [alice:sehrgeheim] 
\end{lstlisting}

\section*{Anhang 4: Chat und so Stuff dem seine Dateien}


\section*{Anhang 5: Ping-Skript (Aufgabe 6.2)}
\begin{lstlisting}[language=Bash]
#!/bin/bash
COUNTER=0
LIMIT=255
while [ $COUNTER -lt $LIMIT ]; do
	echo "pinging 10.1.1.$COUNTER"
	ping -c1 10.1.1.$COUNTER
	let COUNTER=COUNTER+1
done
\end{lstlisting}

\begin{thebibliography}{1}
\bibitem{uwtcpdump}		\url{https://wiki.ubuntuusers.de/tcpdump/}
\bibitem{daniel}		\url{http://danielmessler.com/study/tcpdump/}
\bibitem{alex}			\url{www.alexonlinux.com/tcpdump-for-dummies\#...}
\bibitem{nmap}			\url{https://nmap.org/book/man.html}
\bibitem{wiki3}			\url{https://de.wikipedia.org/wiki/Drei-Wege-Handschlag#/media/File:Three-way-handshake-example.gif}
\end{thebibliography}

\end{document}