\documentclass[twoside]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[ngerman]{babel}
\usepackage[margin=2.5cm]{geometry}
\usepackage{hyperref}
\usepackage{lastpage}
\usepackage{lipsum}

% import math packages
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsthm}
% contradiction lightning
\usepackage{stmaryrd}
% algorithms and pseudo code
\usepackage{algorithmic}
\usepackage{algorithm}
% formatting and layout
\usepackage{color}
\usepackage{fancyhdr}
% settings
\usepackage{perpage}
\MakePerPage{footnote}
% quotation marks
\usepackage[
    left = ``,%
    right = '',%
    leftsub = `,%
    rightsub = '%
]{dirtytalk}
% custom text colors
\definecolor{pblue}{rgb}{0.13,0.13,1}
\definecolor{pgreen}{rgb}{0,0.5,0}
% macro commands
%% requires color package and the custom colors defined here 
\newcommand{\todo}[1]{
	% add TODO to table of contents
	\addcontentsline{toc}{subsubsection}{TODO: #1}
	\textcolor{pgreen}{ % color TODO green
		\texttt{ % make TODO have fancy font
			\-\\ \-\\//TODO: #1\-\\ \-\\
		}
	}
}
\newcommand{\sect}[4]{	%	custom section (level 1)
	\newpage
	\addcontentsline{toc}{section}{Zettel #1 (#2)}
	\section*{Blatt Nr. #1 (Ausgabe: #2, Abgabe: #3)}
	\begin{center}
		\begin{LARGE}
			#4
		\end{LARGE}
	\end{center}
	\label{sec:#1}
}
\newcommand{\sus}[1]{
	\addcontentsline{toc}{subsection}{Aufgabe #1}
	\subsection*{Übungsaufgabe #1}
	\label{ssec:#1}
}
\newcommand{\sss}[1]{
	\addcontentsline{toc}{subsubsection}{Teilaufgabe #1}
	\subsubsection*{Aufgabe #1}
	\label{sssec:#1}
}
\newcommand{\points}[1]{
	\begin{flushright}
		\begin{Large}
			[~~~~\string| ~#1~]
		\end{Large}
	\end{flushright}
}
\newcommand{\tit}[1]{\textit{#1}}
\newcommand{\ttt}[1]{\texttt{#1}}


\newcommand{\command}[1]{\say{\texttt{#1}}}
% tikz
\usepackage{tikz}
\usetikzlibrary{arrows,automata,positioning}
\usepackage{pgf}

\usepackage{listings}
%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Source code inclusion
\definecolor{pblue}{rgb}{0.13,0.13,1}
\definecolor{pgreen}{rgb}{0,0.5,0}
\lstset{ %
language=Java,   							% choose the language of the code
basicstyle=\small\ttfamily,  				% the size of the fonts that are used for the code
numbers=left,                   			% where to put the line-numbers
numbersep=5pt,                  			% how far the line-numbers are from the code
backgroundcolor=\color{light-light-gray},   % choose the background color. You must add
frame=lrtb,           						% adds a frame around the code
tabsize=4,          						% sets default tabsize to 2 spaces
captionpos=b,           					% sets the caption-position to bottom
breaklines=true,        					% sets automatic line breaking
xleftmargin=1.5cm,							% space from the left paper edge
commentstyle=\color{pgreen},
keywordstyle=\color{pblue},
literate=%
    {Ö}{{\"O}}1
    {Ä}{{\"A}}1
    {Ü}{{\"U}}1
    {ß}{{\ss}}1
    {ü}{{\"u}}1
    {ä}{{\"a}}1
    {ö}{{\"o}}1
    {~}{{\textasciitilde}}1
}
\renewcommand{\lstlistingname}{Code}
\definecolor{light-light-gray}{gray}{0.95}

%#+-------------------------------------------------+#%
%#+						VARIABLEN			     	+#%
%#+-------------------------------------------------+#%

\begin{document}

%% Fach-Daten
\newcommand{\fachname}{Projekt Network Security}
\newcommand{\fachnummer}{InfB-Proj}
\newcommand{\veranstaltungsnummer}{64-185}
\newcommand{\stinegruppe}{$ $}
\newcommand{\termin}{Donnerstag, 12.00 - 18.00\\F-027}
%% Gruppenmitglied 1
\newcommand{\memOneName}{Utz Pöhlmann}
\newcommand{\memOneMail}{4poehlma@informatik.uni-hamburg.de}
\newcommand{\memOneNr}{6663579}
%% Gruppenmitglied 2
\newcommand{\memTwoName}{Louis Kobras}
\newcommand{\memTwoMail}{4kobras@informatik.uni-hamburg.de}
\newcommand{\memTwoNr}{6658699}
%% Gruppenmitglied 3
\newcommand{\memThreeName}{}
\newcommand{\memThreeMail}{}
\newcommand{\memThreeNr}{}
%% Gruppenmitglied 4
\newcommand{\memFourName}{}
\newcommand{\memFourMail}{}
\newcommand{\memFourNr}{}
%% Datum
\newcommand{\datum}{\today\\}






%#+-------------------------------------------------+#%
%#+						FORMATIERUNG		     	+#%
%#+-------------------------------------------------+#%

\newcommand{\fach}{
	\begin{Huge}
		\fachname\\
	\end{Huge}
	\begin{LARGE}
		Modul: \fachnummer\\
		Veranstaltung: \veranstaltungsnummer\\
	\end{LARGE}
}

\newcommand{\gruppe}{
	\begin{LARGE}
		\stinegruppe\\
	\end{LARGE}
	\begin{Large}
		\termin\\
	\end{Large}
}

\newcommand{\memberOfGroup}[3]{
	\begin{center}
		\begin{Large}
			#1
		\end{Large}\-\\
		#2\-\\
		#3\-\\
	\end{center}
	\vspace{.5cm}
}
\newcommand{\datumf}{
	\begin{Large}
		\datum\-\\
	\end{Large}
}


% setting up footers and headers
%% setting page style so that footers and headers can be used
\pagestyle{fancy}
%% overwrite default values
\fancyhead{}
\fancyfoot{}
%% first group member in upper left corner
\lhead{\memOneName\-\\\memOneNr}
%% upper center (empty)
\chead{04. Mai 2016\\}
%% second group member in upper right corner
\rhead{\memTwoName\-\\\memTwoNr}
%% lower left corner (empty)
\lfoot{}
%% subject name in lower center
\cfoot{\fachname}
%% lower right corner (empty)
\rfoot{}
%% sets the page number to appear in either the lower left or lower right corner,
%% depending on whether the page number is even or odd, in the format "page X of Y"
\fancyfoot[LE,RO]{Seite \thepage ~von \pageref{LastPage}}
%% thin separation line over the footer
\renewcommand{\footrulewidth}{0.4pt}


%#+-------------------------------------------------+#%
%#+						DECKBLATT  			     	+#%
%#+-------------------------------------------------+#%

%\thispagestyle{empty}
%\-\vspace{0.5cm}
%\begin{center}
%	\fach
%	\vspace{1.5cm}
%	\gruppe
%	\vspace{1.5cm}
%	% group members
%	\memberOfGroup{\memOneName}{\memOneMail}{\memOneNr}
%	\memberOfGroup{\memTwoName}{\memTwoMail}{\memTwoNr}
%	\memberOfGroup{}{}{}
%	\memberOfGroup{}{}{}
%	% 1 cm to next element
%	\vspace{1cm}
%	\datumf
%	
%\end{center}
%\newpage



\sect{2}{14. April 2016}{04. Mai 2016}{Kennwortsicherheit}
\pagenumbering{arabic}
























%#+-------------------------------------------------+#%
%#+						ZETTEL 1					+#%
%#+-------------------------------------------------+#%

\sus{1. Sicherheit lokaler Rechner}
\sss{1.1 Zugriff auf /etc/passwd und /etc/shadow des Webservers}
Überblick über die VM.
\begin{itemize}
	\item \tit{Blatt2-Admin-PC.vmwarevm} wurde aus \tit{/home/vmware} nach \tit{/home/ss16g07/vmware} kopiert
	\item wurde über \tit{\underline{F}ile -> \underline{O}pen...} importiert (die virtuelle Festplatte wurde eingelesen)
	\item VM wurde gestartet; beim Boot wurde danach gefragt, ob die VM kopiert oder verschoben wurde; nach Aufgabe wurde \say{kopiert} ausgewählt
\end{itemize}
Booten von der CD
\begin{itemize}
	\item \tit{grml}-iso wurde aus \tit{/home/vmware} nach \tit{/home/ss16g07/vmware} kopiert
	\item Neues Image wurde in den VM-Einstellungen in das CD-Laufwerk eingelegt
	\item Ebenfalls unter den VM-Einstellungen wurde das CD-Laufwerk verbunden
	\item Während des Bootens der VM wurde das BIOS aufgerufen, um sicherzustellen, dass von der CD gebootet wird
\end{itemize}
Einlesen und durchsuchen der Root-Partition
\begin{itemize}
	\item Wählen des deutschen Tastaturlayouts mit\tit{d} $\rightarrow$ \tit{Enter}
	\item mounten der Festplatte mit \tit{mount -r /dev/sda1}
	\item nach \tit{/etc/fstab} Festplatte nun \tit{/mnt/sda1} zugreifbar
	\item Auslesen der Dateien \tit{/etc/shadow} und \tit{/etc/passwd} mit \tit{cat}
	\begin{itemize}
		\item \tit{passwd} enthält Einträge der folgenden Form: \cite{1}
		\begin{itemize}
			\item \tit{<Nutzername>}:x\footnote{\tit{x} (bei Ubuntu 14: *) indiziert, dass ein verschlüsseltes Passwort für diesen Nutzer in \tit{/etc/shadow} vermerkt ist}:\tit{<Nutzer ID>}:\tit{<Gruppen ID>}:\tit{<Nutzer ID Info>}:\tit{<home-Verzeichnis>}:\tit{<Shell>}
		\end{itemize}
		\item \tit{shadow} enthält Einträge der folgenden Form: \cite{2}
		\begin{itemize}
			\item \tit{<Nutzername>}:\tit{<verschlüsseltes Password>}:\tit{<Tag der letzen Passwortänderung>}\footnote{in Tagen seit dem 1. Jan 1970}:\tit{<minimaler Zeitabstand zwischen Passwortänderungen>}\footnote{Zeit, bis das Passwort wieder geändert werden kann}:\tit{<maximaler Zeitabstand zwischen Passwortänderungen>}\footnote{Zeitpunkt, an dem das Passwort verfällt}:\tit{<Warnungszeitraum für auslaufende Passwörter>}:\tit{<Zeit nach der ein Password ausläuft>}\footnote{nach Inaktivität des Accounts}:\tit{<Zeit, die seit der Inaktivität des Accounts vergangen ist>}
		\end{itemize}
	\end{itemize}
	\item es gibt die Benutzer \tit{webadmin} und \tit{georg}
	\item Herausfinden der Nutzergruppen mit \tit{cat group} | \tit{grep <Benutzername>}\footnote{Durch die | wird die Ausgabe von \tit{cat group} an den \tit{grep}-Befehl weitergegeben, der alles herausfiltert, was nicht zum ihm angegebenen Parameter passt}
	\begin{itemize}
		\item georg : admin georg 
		\item webadmin : adm dialout cdrom plugdev lpadmin webadmin sambashare
	\end{itemize}
\end{itemize}
\sss{1.2 Auslesen von Kennwörter}
\begin{itemize}
	\item salting: Hinzufügen einer zufälligen Zeichenkette (\say{salt})
	\item hashing: Umrechnung der Daten in Hash-Werte\footnote{Werte fester Länge, typischerweise hexadezimal codiert \cite{3}}
\end{itemize}
Installieren und Verwendung von \tit{john}
\begin{itemize}
	\item John wurde installiert mit \tit{apt-get install john}, es konnte jedoch nicht authentifiziert werden
	\item Einfaches Ausführen von \tit{john} zeigt die Hilfe-Seite
	\item Eingabe des Befehls \tit{john --incremental --users=webadmin /mnt/sda1/etc/shadow}, um das Passwort von \tit{webadmin} im \tit{incremental}-Mode zu ermitteln
	\item Nach 5 Minuten wurde eine manuelle Terminierung durchgeführt
\end{itemize}
Wörterbuchangriff
\begin{itemize}
	\item es wurde in das home Verzeichnis navigiert damit wieder Schreibzugriff besteht
	\item mit \tit{wget http:download.openwall.net/pub/wordlists/all.gz} wurde ein Wörterbuch runtergeladen
	\item durch \tit{gunzip all.gz} wurde das Wörterbuch entpackt
	\item und mit \tit{john --wordlist=all --users=webadmin /mnt/sda1/etc/shadow} der Angriff gestartet
	\item nach 21.01 sec war das Passwort herausgefunden: mockingbird
\end{itemize}
\sss{1.3 Setzen von neuen Kennwörtern}
\begin{itemize}
	\item Das Passwort von georg ist nicht ohne weiteres ermittelbar, weil es wahrscheinlich nicht im Wörterbuch steht
	\item zum unmounten von sda1 wurde \tit{umount /dev/sda1} eingegeben
	\item zum erneuten mounten wurde \tit{mount -w /dev/sda1} eingegeben
	\item zum Ändern des root Verzeichnsises mit shell Wechsel wurde \tit{chroot /mnt/sda1/ /bin/sh} eigegeben
	\item nun wurde das Passwort von georg auf \tit{1} gesetzt: \tit{passwd georg 1}
	\item es wurde das sytem durch \tit{exit} gefolgt von \tit{shutdown -r now} neu gestartet und sich als georg eingeloggt
\end{itemize}



\sus{2. Sichere Speicherung von Kennwörtern}
\sss{2.1 Angriffe mit Hashdatenbanken und Rainbow-Tables}
\begin{itemize}
	\item es wurde in das home Verzeichnis von webadmin navigiert durch \tit{cd /home/webadmin/}
	\item Wechseln in das Unterverzeichnis \tit{Rainbowtables/rcracki}
	\item Ausführung von \tit{rcracki} mit \tit{./rcracki <table-path> -l <password-file>}
	\item es konnten nicht alle Passwörter ermittelt werden.Vermutlich weil nicht alle Passwörter in der benutzten RainbowTable codiert waren
	\item eigene Programme sind immer gut, weil man weiß, was sie können, dementprecehnd dauert es aber auch lange, viel Umfang einzbauen
	\item diese Speicherung würde (da jedes Passwort einen Hash der Länge 128 Bit\cite{wikimd5} generiert) $\Sigma_{i=1}^{7} 128^i$ Bit $\hat{\approx}$ 71 Terabyte verbrauchen, während eine der gegebenen Rainbowtables nur ca. 40 MB groß ist
\end{itemize}
\sss{2.2 Eigener Passwort-Cracker}
Quellcode zu dieser Aufgabe zu finden unter \textbf{\nameref{gen}}
\paragraph{Passwort:} s1v3s
\paragraph{Lösungsweg:}
\begin{itemize}
	\item Darstellung der Passwortstellen wie \dq Walzen\dq bei einem Zahlenschloss (Wert von a bis 9)
	\item Senden eines Ticks an die Walzen
	\item Erste Walze wird gedreht, bei Überlauf Weitergabe an nächste Walze (rekursiv über alle sechs Walzen)
	\item Startwert jeder Walze ist \dq ~\dq
	\item Abfragen des Walzenstandes (Char-Sequenz) nach jedem Tick
	\item abgefragten Stand mit salt konkatenieren und hashen
	\item Kombinationen reichen von \dq a\dq ~bis \dq 999999\dq
	\item Abbruch, wenn gehashte Kombination mit gegebenem Hash übereinstimmt
\end{itemize}
\sss{2.3 Eigene Kennwort-Speicherfunktion in Java}
Quellcode zu dieser Aufgabe zu finden unter \textbf{\nameref{admin}}

\paragraph{Funktionalität:}
\begin{itemize}
	\item Speicherformat: \texttt{username:salt:password-hash}
	\item Speicherort: Festgelegt auf \texttt{\textasciitilde/Documents/passwoerter.txt}
	\begin{itemize}
		\item Verbesserungsoption: Benutzer den Speicherpfad angeben lassen
	\end{itemize}
	\item 5000-maliges hashen des Passwortes
	\item \texttt{checkUser} nimmt das Nutzer-Passwort-Tupel entgegen, hasht das Salt-Passwort-Tupel 5000 mal und vergleicht mit dem Nutzer-Hash-Tupel im Speicher
	\item \textit{main}-Methode nimmt als zusätzliche Parameter Methodennamen und Nutzernamen entgegen
	\item Eingabeaufforderung für Passwort (vgl. Zusatzfrage, s.u.)
	\item Vorhandene Datensätze werden überschrieben
\end{itemize}

\paragraph{Zusatzfrage.}
Wenn das Passwort als Konsolenparameter übergeben wird, ist es in der Historie einzusehen und kann über \texttt{script} gespeichert werden.
Aus diesem Grund wurde sich dazu entschieden, das Passwort über ein \texttt{JOPtionPane} im Programm abzufragen.

\sus{3. Forensische Wiederherstellung von Kennwörtern}
\sss{3.1}
\begin{itemize}
	\item Speicherorte: Swap, Registry, bash-history
\end{itemize}
\sss{3.2}
Es wurde die bash-Chronik ausgelesen mit \texttt{/mnt/sda1/home/user \# cat .bash\textunderscore  history}.\\
Inhalt:
\begin{itemize}
	\item reboot
	\item cat /etc/inittab
	\item man intro
	\item man ls
	\item exit
	\item vi /etc/sudoers
	\item top
	\item pico
	\item cd
	\item exit
	\item java
	\item cd Desktop
	\item jedit wp-config.php
	\item scp wp-config.php root@10.1.1.2:/var/www/wordpress/
	\item rm wp-config.php
	\item exit
\end{itemize}



\sss{3.3}
Es wurden folgende Passwörter gefunden:
\begin{itemize}
	\item \textbf{user:} bloguser\\
			\textbf{password:} Flugentenfederkiel/991199
	\item \textbf{user:} blog\textunderscore user\\
			\textbf{password:} DUzvAu22cKatsXyV
	\item \textbf{user:} bloguser\\
			\textbf{password:} Kindergeburtstag/119911
\end{itemize}
Der letzte Eintrag führte zum erfolgreichen Login.

\sus{4. Unsicherer Umgang mit Passwörtern in Java}
\begin{itemize}
	\item Mögliche Sicherheitslücke in Klasse \texttt{transport/HTTPTransport.java}
	\item entschlüsseltes Passwort wird in String gespeichert
	\item nach \cite{lnxspeicher} sind Strings im Speicher auslesbar
	\item alternativ kann Prozess gedumped werden, womit später der Dump ausgelesen werden kann
\end{itemize}


\begin{thebibliography}{1}
\bibitem{1} http://www.cyberciti.biz/faq/understanding-etcpasswd-file-format/
\bibitem{2} http://www.cyberciti.biz/faq/understanding-etcshadow-file/
\bibitem{3} http://zeitstempel.hauke-laging.de/hashinfo.php
\bibitem{wikimd5} http://de.wikipedia.org/wiki/Message-Digest\textunderscore Algorithm\textunderscore 5
\bibitem{lnxspeicher} http://www.foo.be/course/dess-20082009/davidoff-clearmem-linux.pdf
\end{thebibliography}

\newpage
\section*{Anhang I: Erinnerungshilfe}
\label{gen}
Startklasse:
\begin{lstlisting}
package zwei.zwei;

public class Startup {

    private static String password;
    public static void main (String[] args){
        Erinnerungshilfe eh = new Erinnerungshilfe();
        password = eh.get_passwort();
        System.out.println("Passwort: " + password);
    }
}
\end{lstlisting}
Eigentliche Erinnerungshilfe:
\begin{lstlisting}
package zwei.zwei;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.ArrayList;

public class Erinnerungshilfe {
	// Halterung für die Walzen
	private ArrayList<Integer> _walzen;
	// Speicher für das aktuelle Passwort
	private String _passwort;
	// Halterung für alle gültigen Symbole
	private ArrayList<String> _charListe;
	// Liste aller gültigen Symbole
	private String _symbols;
	// Halterung für Salt
	private String _salt;
	// Walze, die zur Zeit die letzte ist, welche bearbeitet wird.
	private int _aktuelleWalze;

	/**
	 * Konstruktor. Ohne Angabe eines Salts wird der Salt aus der Aufgabe
	 * verwendet
	 */
	public Erinnerungshilfe() {
		this("8kofferradio");
	}

	/**
	 * Konstruktor. Probiert automatisch alle Passwörter durch
	 */
	public Erinnerungshilfe(String salt) {
		_walzen = new ArrayList<Integer>();
		setupWalzenListe();
		_passwort = "";
		_symbols = "abcdefghijklmnopqrstuvwxyz0123456789";
		_charListe = new ArrayList<String>();
		setupCharListe();
		_salt = salt;
		findePasswort();
	} // end Konstruktor

	/**
	 * Iteriert über die Walzen, bis die Abbruchbedingung erfüllt ist oder
	 * alle Werte ausprobiert wurden
	 */
	private void findePasswort() {
		_aktuelleWalze = 0;
		while (_aktuelleWalze != _walzen.size()) {
			tick(_walzen.get(_aktuelleWalze));
			String hashPasswort = getMD5Hash(_salt.concat(_passwort));
			System.out.println(_passwort);

			if (hashPasswort.equals("2b2935865b8a6749b0fd31697b467bd7")) {
				break;
			}
			_passwort = "";
		}
	} // end findePasswort()

	/**
	 * Dreht die gegebene Walze um ein Feld weiter. Bei Überlauf wird die Walze
	 * zurückgesetzt und die nächste Walze rekursiv aufgerufen. Anschließend
	 * wird das zum aktuellen Walzenstand gehörende Passwort generiert.
	 * 
	 * @param walze
	 *            der Stand der aktuellen Walze
	 * @param walzenIndex
	 *            der Index der aktuellen Walze (wichtig zum Ändern des Wertes
	 *            im Walzenarray)
	 */
	private void tick(int walze) {
		walze += 1;
		_walzen.set(_aktuelleWalze, walze); // setzt den Wert der Walze auch im
		// Array
		if (walze == _symbols.length()) {
			_aktuelleWalze = rolleWalze(_aktuelleWalze); // setzt die nächste
			// Walze weiter
			// walze = _walzen.get(walzenIndex);
			if (_aktuelleWalze < _walzen.size()) {
				walze = 0; // setzt die aktuelle Walze zurück
				_walzen.set(_aktuelleWalze, walze); // setzt den Wert der Walze
				// auch im Array
			}
		}
		if (_aktuelleWalze < _walzen.size()) {
			for (int w : _walzen) {
				if (w >= 0) {
					_passwort += getSymbol(w);
				}
			}
		}
	} // end tick(int)

	/**
	 * Wird aufgerufen, sobald eine Walte komplett durchgedreht hat. Setzt die
	 * nächste Walze einen Index weiter. Methode: Walze 1 dreht durch. Walze 1
	 * wird wieder auf Wert 1 gesetzt. Walze 2 dreht durch. Walze 2 wird wieder
	 * auf Wert 1 gesetzt und Walze 1 wird einen Wert weiter gesetzt. Walte 2
	 * dreht durch. usw.
	 * 
	 * @param walzenIndex
	 *            der Index der aktuell durch gedrehten Walze
	 * @return der Index der neuen aktuellen Walze
	 */
	private int rolleWalze(int walzenIndex) {
		if (walzenIndex == 0) {
			if (_walzen.get(walzenIndex) >= 35) {
				_walzen.set(walzenIndex, 0);
				return walzenIndex + 1; // gehe zur nächsten Walze
			} else {
				_walzen.set(walzenIndex, _walzen.get(walzenIndex) + 1);
				return walzenIndex;
			}
		} else if (0 < walzenIndex && walzenIndex < _walzen.size()) {
			if (_walzen.get(walzenIndex) >= 35) {
				_walzen.set(walzenIndex, 0);
				return rolleWalze(walzenIndex - 1) + 1; // setze letzte Walze +1
			} else {
				_walzen.set(walzenIndex, _walzen.get(walzenIndex) + 1);
				return walzenIndex;
			}
		}
		return -1; // Hier kommt das Programm nie an
    }

    /**
     * Holt ein Symbol aus der Symbolliste
     * 
     * @param index
     *            der Index des Symbols
     * @return das Symbol
     */
    private String getSymbol(int index) {
    	return "" + _symbols.charAt(index);
    } // end getSymbol()
    
    /**
     * setzt die gültigen Symbole in einer Liste auf
     */
    private void setupCharListe() {
        for (int i = 0; i < _symbols.length(); i++) {
            _charListe.add(i, _symbols.substring(i, i + 1));
        }
    } // end setupCharListe()

    /**
     * setzt die Walzen auf und sortiert sie in einer Liste
     */
    private void setupWalzenListe() {
        int walze0 = -1;
        int walze1 = -1;
        int walze2 = -1;
        int walze3 = -1;
        int walze4 = -1;
        int walze5 = -1;
        _walzen.add(0, walze0);
        _walzen.add(1, walze1);
        _walzen.add(2, walze2);
        _walzen.add(3, walze3);
        _walzen.add(4, walze4);
        _walzen.add(5, walze5);
    } // end setupWalzenListe()

    /**
     * Eine Methode zum einhashen von Srings im md5 Format
     * 
     * @param yourString
     *            Der String der gehasht werden soll
     * @return Der gehashte String
     */
    private String getMD5Hash(String yourString) {
        MessageDigest md = null;
        try {
            md = MessageDigest.getInstance("MD5");
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        }
        md.update(yourString.getBytes());
        byte[] digest = md.digest();
        StringBuffer sb = new StringBuffer();
        for (byte b : digest) {
            sb.append(String.format("%02x", b & 0xff));
        }
        return sb.toString();
    } // end getMD5Hash(String)
	
    /**
     * gettermethode für _passwort
     * 
     * @return
     * 			_passwort
     */
    public String get_passwort() {
        return _passwort;
    } // end get_passwort()

} // end class
\end{lstlisting}

\newpage
\section*{Anhang II: Useradmin-Klasse}
\label{admin}
Interface \texttt{Useradmin}
\begin{lstlisting}
package zwei.drei;

/**
 * Kennwortverwalter
 * 
 * @author georg
 *
 */
public interface Useradministration {
	
	/**
	 * füge Nutzer hinzu
	 * 
	 * @param username
	 * 				der Nutzer
	 * @param password
	 * 				sein Passwort
	 */
	public void addUser(String username, char[] password);
	
	/**
	 * prüft, ob das Passwort gültig ist
	 * 
	 * @param username
	 * 				der Nutzer
	 * @param password
	 * 				sein Passwort
	 * @return
	 * 				ist das Passwort gültig?
	 */
	public boolean checkUser(String username, char[] password);
}
\end{lstlisting}
Implementierende Klasse:
\begin{lstlisting}
package zwei.drei;

import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.ArrayList;

public class Useradmin implements Useradministration {

	private RandomSalt _rs;
	private DateiVerwalter _ds;

	public static void main(String[] args) {
		if (args.length == 3) {
			Useradmin ua = new Useradmin();
			String name = args[1];
			char[] passwort = args[2].toCharArray();
			if (args[0].equals("addUser"))
				ua.addUser(name, passwort);
			else if (args[0].equals("checkUser"))
				System.out.println(ua.checkUser(name, passwort));
			else
				System.out.println("Nein");

		} else
			System.out.println("Nein");
	}

	public Useradmin() {
		_rs = new RandomSalt();
		_ds = new DateiVerwalter();
	}

	@Override
	public void addUser(String username, char[] password) {
		String salt = _rs.getRandomSalt();
		String hash = hash1k(salt.concat(String.copyValueOf(password)));
		_ds.fuegeInhaltHinzu(username + ":" + salt + ":" +  hash);
		_ds.write();
	}

	private String hash1k(String hash) {
		for (int i = 0; i < 1001; i++) {
			hash = getSHA512Hash(hash);
		}
		return hash;
	}

	@Override
	public boolean checkUser(String username, char[] password) {
		ArrayList<String> list = _ds.read();
		String[] laufstring;
		String nutzer;
		String salt;
		String hash;
		for (String s : list) {
			laufstring = s.split(":");
			nutzer = laufstring[0];
			salt = laufstring[1];
			hash = laufstring[2];
			if (nutzer.equals(username) && hash.equals(hash1k(salt
					.concat(String.copyValueOf(password)))))
					return true;
			
		}
		return false;
	}

	/**
	 * Eine Methode zum einhashen von Srings im SHA512 Format
	 * 
	 * @param yourString
	 *            Der String der gehasht werden soll
	 * @return Der gehashte String
	 */
	private String getSHA512Hash(String yourString) {
		MessageDigest md = null;
		try {
			md = MessageDigest.getInstance("SHA-512");
		} catch (NoSuchAlgorithmException e) {
			e.printStackTrace();
		}
		md.update(yourString.getBytes());
		byte[] digest = md.digest();
		StringBuffer sb = new StringBuffer();
		for (byte b : digest) {
			sb.append(Integer.toString((b & 0xff) + 0x100, 16).substring(1));
		}
		return sb.toString();
	} // end getMD5Hash(String)
}
\end{lstlisting}
Datentyp \say{\texttt{DateiVerwalter}}:
\begin{lstlisting}
package zwei.drei;

import java.util.ArrayList;
import java.util.Random;

/**
 * generiert random Salts
 * 
 * @author georg
 *
 */
public class RandomSalt {

	// Halterung für die Walzen
	private ArrayList<Integer> _walzen;
	// Halterung für alle gültigen Symbole
	private ArrayList<String> _charListe;
	// Liste aller gültigen Symbole
	private String _symbols;
	// Random Event
	private Random _rn;

	/**
	 * Konstruktor
	 */
	public RandomSalt() {
		_rn = new Random();
		_walzen = new ArrayList<Integer>();
		_symbols = "abcdefghijklmnopqrstuvwxyz0123456789";
		_charListe = new ArrayList<String>();
		setupCharListe();
	}

	/**
	 * erstellt einen random String
	 * 
	 * @return
	 * 				ein random String
	 */
	public String getRandomSalt() {
		setupWalzenListe();
		
		String salt = "";
		for (int w : _walzen) {
			if (w >= 0) {
				salt += getSymbol(w);
			}
		}
		_walzen.clear();
		return salt;
	}

	/**
	 * Holt ein Symbol aus der Symbolliste
	 * 
	 * @param index
	 *            der Index des Symbols
	 * @return das Symbol
	 */
	private String getSymbol(int index) {
		return "" + _symbols.charAt(index);
	} // end getSymbol()

	/**
	 * setzt die gültigen Symbole in einer Liste auf
	 */
	private void setupCharListe() {
		for (int i = 0; i < _symbols.length(); i++) {
			_charListe.add(i, _symbols.substring(i, i + 1));
		}
	} // end setupCharListe()

	/**
	 * setzt die Walzen auf und speichert sie in einer Liste,
	 * zusammen mit ihrem Ausgabewert
	 */
	private void setupWalzenListe() {
		int anzahl = Zufall(0, 20);

		for (int i = 0; i < anzahl; i++) {
			_walzen.add(i, Zufall(0, 35));
		}
	} // end setupWalzenListe()

	/**
	 * generiert eine Zufallszahl zwischen min und max
	 * 
	 * @param min 
	 * 				Untergrenze
	 * @param max
	 * 				Obergrenze
	 * @return
	 * 				der Zufallswert
	 */
	private int Zufall(int min, int max) {
		return _rn.nextInt(max - min + 1) + min;
	}
}

\end{lstlisting}
Datentyp \say{\texttt{RandomSalt}}:
\begin{lstlisting}
package zwei.drei;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Scanner;

public class DateiVerwalter {

	private ArrayList<String> _passwoerter;
	private String _filePath;

	public DateiVerwalter() {
		_passwoerter = new ArrayList<String>();
		String OS = System.getProperty("os.name");
		_filePath = System.getProperty("user.home");
		// Anpassen des Dateipfads entsprechend dem Host-OS
		if (OS.startsWith("Windows")) {
			_filePath += "\\Documents\\passwörter.txt";
		} else if (OS.startsWith("Linux")) {
			_filePath += "/Documents/passwörter.txt";
		}
		_passwoerter = read();
	}

	/**
	 * fügt einen String an die Ausgabe an
	 * 
	 * @param inhalt
	 *            der String
	 * 
	 */
	public void fuegeInhaltHinzu(String inhalt) {
		String[] laufstring;
		String[] laufstringInhalt;
		ArrayList<String> passwoerterBuffer = new ArrayList<String>(_passwoerter);
		for (String s : _passwoerter) {
			laufstring = s.split(":");
			laufstringInhalt = inhalt.split(":");
			if (laufstring[0].equals(laufstringInhalt[0]))
				passwoerterBuffer.remove(s);
		}
		_passwoerter = passwoerterBuffer;
		_passwoerter.add(inhalt);
	} // end fuegeInhaltHinzu(String)

	/**
	 * fügt ein StringAray an die Ausgabe an
	 * 
	 * @param inhalt
	 *            der String
	 * 
	 */
	public void fuegeInhaltHinzu(ArrayList<String> inhalt) {
		_passwoerter.addAll(inhalt);
	} // end fuegeInhaltHinzu(ArrayList<String>)

	/**
	 * Schreibt die Passwortliste in eine Datei 'passwörter.txt' im
	 * Dokumente-Ordner im Home-Verzeichnis des Nutzers
	 */
	public void write() {
		File file = new File(_filePath);
		try {
			if (!file.exists()) {
				file.createNewFile();
			}
			FileWriter fw = new FileWriter(file);
			BufferedWriter bw = new BufferedWriter(fw);
			for (int i = 0; i < _passwoerter.size(); i++) {
				bw.write(_passwoerter.get(i));
			}
			bw.flush();
			bw.close();
		} catch (Exception e) {
			System.out.println("There was a problem writing your file");
		}
	} // end write()

	/**
	 * Liest ein Dokument aus
	 */
	public ArrayList<String> read() {
		ArrayList<String> list = new ArrayList<String>();
		try {
			Scanner s = new Scanner(new File(_filePath));
			while (s.hasNextLine()) {
				list.add(s.nextLine());
			}
			s.close();
		} catch (IOException e) {
			e.printStackTrace();
		}
		return list;
	} // end read()
}
\end{lstlisting}
\end{document}