\documentclass[parskip,12pt,paper=a4,sffamily]{scrartcl}
%alternate documentclass:
%\documentclass[parskip,12pt,paper=a4,sffamily]{article}
\usepackage[utf8]{inputenc}
\usepackage[ngerman]{babel}
\usepackage{lastpage}
\usepackage{color}   %May be necessary if you want to color links
\usepackage{hyperref}
% code snippets
\usepackage{listings}
% listing captions
\usepackage{caption}
% font: times new roman
\usepackage{times}
% tikz being tikz
\usepackage{tikz}
% import math packages
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsthm}
% contradiction lightning
\usepackage{stmaryrd}
% alignment options
\usepackage{ragged2e}
% page margins
\usepackage[margin=2.5cm]{geometry}

\definecolor{pblue}{rgb}{0.13,0.13,1}
\definecolor{pgreen}{rgb}{0,0.5,0}


\lstset{ %
language=Java,   							% choose the language of the code
basicstyle=\small\ttfamily,  				% the size of the fonts that are used for the code
numbers=left,                   			% where to put the line-numbers
numbersep=5pt,                  			% how far the line-numbers are from the code
backgroundcolor=\color{light-light-gray},   % choose the background color. You must add
frame=lrtb,           						% adds a frame around the code
tabsize=4,          						% sets default tabsize to 2 spaces
captionpos=b,           					% sets the caption-position to bottom
breaklines=true,        					% sets automatic line breaking
xleftmargin=1.5cm,							% space from the left paper edge
commentstyle=\color{pgreen},
keywordstyle=\color{pblue},
literate=%
    {Ö}{{\"O}}1
    {Ä}{{\"A}}1
    {Ü}{{\"U}}1
    {ß}{{\ss}}1
    {ü}{{\"u}}1
    {ä}{{\"a}}1
    {ö}{{\"o}}1
    {~}{{\textasciitilde}}1
}
\renewcommand{\lstlistingname}{Code}
\captionsetup[lstlisting]{font={footnotesize},margin=1.5cm,singlelinecheck=false } % removes "Listing 1: "
\definecolor{light-light-gray}{gray}{0.95}
\let\stdsection\section
\renewcommand\section{\stdsection}

% add line break for subtitle (size: large)
\title{Some Title
    \\\large{
        Some Subtitle
    }
}
\author{~\\
	\Large{Louis Kobras}\\
	\large{6658699}\\ %Matrikelnummer; wenn nicht für Uni, auskommentieren
	\large{4kobras@informatik.uni-hamburg.de}\\
	\\
	\Large{Utz Pöhlmann}\\
	\large{6663579}\\
	\large{4poehlma@informatik.uni-hamburg.de}\\
	\\
	\Large{Philipp Quach}
	\large{6706421}\\
	\large{4quach@informatik.uni-hamburg.de}
}

% leave empty for no date on title page
% comment for auto-generated date
\date{}


\begin{document}
	\maketitle
	\newpage
	\section*{Aufgabe 5.4}
	\label{sec:a5.4}
	\newpage
	\section*{Aufgabe 5.5}
	\label{sec:a5.5}
	\[ G=\{V_N,V_T,P,S\} \]
	\[ L(G) := \{ w \in V_T^* | S \underset{G}{\overset{*}{\Rightarrow}} w \} \]
	\[ V_T:=\{a,b,c\}\]
	\[V_N:=\{S,A,B,C\}\]
	\[S:=S\]
	\[P:=\{S \rightarrow ABC,~A\rightarrow aA|\lambda,~B\rightarrow aBb|\lambda,~C\rightarrow bCc|\lambda\}\]
	\\
	$L_1 \subset L(G)$\\
	\[L_1=\{a^j a^i b^k c^k~|~i,j,k \ge 0\}\]
	Es werden erst beliebig viele $a$s (I), dann $a^xb^x$ (II) und zum Schluss $b^yc^y$ (III) gelesen ($x,y\in \mathbb{N} _0$).\\
	I ist gegeben durch $S\rightarrow ABC~\cap~A\rightarrow aA|\lambda$\\
	\-~~~~$\Rightarrow$ für A kann man schreiben $a^n|n\in\mathbb{N}_0~~(\hat{=}a^j)$ \\
    II ist gegeben durch $S\rightarrow ABC~\cap~B\rightarrow aBb|\lambda$\\
    \-~~~~$\Rightarrow$ für B kann man schreiben $a^nb^n|n\in\mathbb{N}_0~~(\hat{=}a^i b^i)$ \\
    III ist gegeben durch $S\rightarrow ABC~\cap~C\rightarrow bCc|\lambda$\\
    \-~~~~$\Rightarrow$ für C kann man schreiben $b^nc^n|n\in\mathbb{N}_0~~(\hat{=}k^kc^k)$\\
    \[\Rightarrow a^j a^i b^i b^k c^k~=~a^{i+j}b^{i+k}c^k~~~~|i,j,k \ge 0 ist gegeben\]
    \[\Rightarrow L_1=L(G)~~und~insb.\]
    \[L_1 \subset L(G)~(G~erzeugt~jedes~Wort~aus~L_1)\]
	\newpage
	\section*{Aufgabe 5.6}
	\label{sec:a5.6}
	\subsection*{Teilaufgabe 1.}
	\label{ssec:5.6.1}
	Die einfachste Möglichkeit wäre es, eine TM mit zwei Bändern zu benutzen.
	Dann kann das zweite Band wie ein Keller (i.F. 'Stack') behandelt werden:\\
	Wird etwas auf den Stack gepusht, fährt der Automat zu der entsprechenden Position auf dem zweiten Band und schreibt, um danach wieder zurück zu der Stelle im Wort zurückzugehen, von der aus der Stack aufgerufen wurde.
	Wird etwas gepopt, so fährt der Automat wieder zu der entsprechenden Stelle und löscht; anschließend fährt er zurück zu der Stelle im Wort, von der aus der Stack aufgerufen wurde. \\
	Da zu jedem PDA, der mit leerem Keller akzeptiert, ein PDA existiert, welcher mit Endzuständen akzeptiert, nimmt man nun jenen mit Endzustand.
	Da jede Kante des PDA mehrere Kanten der TM ersetzt wurde, nämlich eine für den Schreibvorgang, eine für den Löschvorgang und jeweils ausreichend, um zu den jeweiligen Stellen auf Band 2 zu gelangen, gelangt der Automat letztendlich auch in einen Endzustand.
	\subsection*{Teilaufgabe 2.}
	\label{ssec:5.6.2}
	Zunächst werden $n~a$s gelesen.
	Für jedes $a$ wird ein $A$ auf Band 2 geschrieben.\\
	Für jedes $b$ wird ein $A$ auf Band 2 in ein $B$ konvertiert.\\
	Analog dazu wird für jedes gelesene $c$ ein $B$ in ein $C$ konvertiert.\\
	Nachdem das erste $b$ gelesen wurde, kann kein $A$ mehr geschrieben werden.
	Mit $a*b*a$ fährt der Automat in einen Fehlerzustand $Z_{ERROR}$.\\
	Analog für $c$ in Abhängigkeit von $b$ und $a$.\\
	Daraus folgt ein Wortaufbau in der Form $a^*b^*c^*$.\\
	Sollten nun beispielsweise bei einem $b$ (analog dazu $c$) mehr $b$s folgen, als $A$s auf Band 2 stehen, wird $Z_{ERROR}$ aufgerufen.\\
	$\Rightarrow a^nb^mc^o|n\ge m\ge o$\\
	Am Ende wird nur noch geprüft, ob auf Band 2 ausschließlich $C$ (und etwaige $#$) stehen.
	Wenn ja, so wurden alle $A$s in $B$s und alle $B$s in $C$s konvertiert, woraus folgt, dass es jeweils gleich viele gewesen sein müssen.
	$\Rightarrow a^nb^mc^o|n=m=o$.
\end{document}